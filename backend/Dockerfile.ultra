# Ultra-optimized Dockerfile for Elastic Beanstalk
# Designed to build in under 10 minutes by maximizing caching and minimizing build time

FROM python:3.12-slim-bookworm AS base

# Set environment variables
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV PIP_NO_CACHE_DIR=1
ENV PIP_DISABLE_PIP_VERSION_CHECK=1

# Builder stage - focus on speed with aggressive caching
FROM base AS builder

# Install only essential build dependencies in one layer
RUN apt-get update && apt-get install --no-install-recommends -y \
    build-essential \
    pkg-config \
    libpq-dev \
    libjpeg-dev \
    zlib1g-dev \
    libffi-dev \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements/ /requirements/

# Use pip's caching and wheel building in parallel where possible
# Install popular packages first that are less likely to change
RUN pip install --upgrade pip wheel setuptools

# Build wheels for all dependencies at once
# Use --find-links to potentially use pre-built wheels from PyPI
RUN pip wheel \
    --wheel-dir /wheels \
    --find-links https://files.pythonhosted.org/packages \
    --prefer-binary \
    -r /requirements/production.txt

# Production stage - minimal and fast
FROM base AS production

WORKDIR /app

# Install only runtime dependencies (minimal set)
RUN apt-get update && apt-get install --no-install-recommends -y \
    libpq5 \
    libjpeg62-turbo \
    libssl3 \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Copy and install pre-built wheels
COPY --from=builder /wheels /wheels

# Install all wheels at once (faster than individual installs)
RUN pip install --no-deps --find-links /wheels /wheels/*.whl \
    && rm -rf /wheels /root/.cache/pip

# Copy application code (do this last for better caching)
COPY . /app/

# Create directories and set permissions in one layer
RUN mkdir -p /app/staticfiles /app/media \
    && chmod -R 755 /app

# Create optimized startup script
RUN echo '#!/bin/bash\n\
set -e\n\
echo "=== Starting BunkLogs Django Application ==="\n\
\n\
# Quick health check\n\
python -c "import django; print(f\"Django {django.get_version()} loaded successfully\")" || exit 1\n\
\n\
# Run migrations with timeout\n\
timeout 300 python manage.py migrate --noinput || {\n\
    echo "Migration timeout or failure - continuing with startup"\n\
}\n\
\n\
# Collect static files with timeout\n\
timeout 180 python manage.py collectstatic --noinput --clear || {\n\
    echo "Static collection timeout or failure - continuing with startup"\n\
}\n\
\n\
# Compile messages if they exist\n\
if [ -d "locale" ]; then\n\
    timeout 60 python manage.py compilemessages || echo "Message compilation failed"\n\
fi\n\
\n\
echo "=== Starting Gunicorn Server ==="\n\
exec gunicorn \\\n\
    --bind 0.0.0.0:8000 \\\n\
    --workers 3 \\\n\
    --worker-class gthread \\\n\
    --threads 2 \\\n\
    --timeout 120 \\\n\
    --keep-alive 5 \\\n\
    --max-requests 1000 \\\n\
    --max-requests-jitter 100 \\\n\
    --preload \\\n\
    --log-level info \\\n\
    config.wsgi:application\n\
' > /app/start.sh && chmod +x /app/start.sh

# Health check for faster startup detection
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/', timeout=5)" || exit 1

EXPOSE 8000

# Use exec form for better signal handling
CMD ["/app/start.sh"]
